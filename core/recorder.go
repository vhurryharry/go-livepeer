package core

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"sync"

	"github.com/livepeer/lpms/ffmpeg"
)

type Recorder struct {
	node   *LivepeerNode
	params *StreamParameters

	// The following need to be protected by the mutex `mu`
	mu   *sync.Mutex
	segs []int32
}

func NewRecorder(node *LivepeerNode, params *StreamParameters) (*Recorder, error) {

	// TODO Should we make this persistent by writing to disk?
	return &Recorder{
		node: node, params: params,
		mu: &sync.Mutex{}, segs: make([]int32, 0, 3600),
	}, nil
}

func (r *Recorder) RecordSegment(segNo int32) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.segs = append(r.segs, segNo)
}

func (r *Recorder) Complete() error {
	sort.Slice(r.segs, func(i, j int) bool { return r.segs[i] < r.segs[j] })
	concatFiles := []*os.File{}
	source := ffmpeg.VideoProfile{Name: "source", Format: r.params.Format}
	renditions := append(r.params.Profiles, source)
	defer func() {
		for _, f := range concatFiles {
			f.Close()
		}
	}()
	for _, v := range renditions {
		fname := filepath.Join(r.node.MediaDir, string(r.params.ManifestID), v.Name+".ffconcat")
		f, err := os.Create(fname)
		if err != nil {
			return err
		}
		fmt.Fprintln(f, "ffconcat version 1.0")
		fmt.Fprintln(f, "# Auto-generated by Livepeer version ", LivepeerVersion)
		concatFiles = append(concatFiles, f)
	}
	r.mu.Lock()
	for _, seg := range r.segs {
		segName := strconv.Itoa(int(seg))
		for i, v := range renditions {
			fname := filepath.Join(v.Name, segName+ffmpeg.FormatExtensions[v.Format])
			fmt.Fprintln(concatFiles[i], "file ", fname)
		}
	}
	r.mu.Unlock()
	for i, f := range concatFiles {
		oname := fmt.Sprintf("%s_%s.mp4", r.params.ManifestID, renditions[i].Name)
		err := ffmpeg.Transcode2(&ffmpeg.TranscodeOptionsIn{Fname: f.Name()},
			[]ffmpeg.TranscodeOptions{{
				Oname:        filepath.Join(r.node.RecordingDir, oname),
				VideoEncoder: ffmpeg.ComponentOptions{Name: "copy"},
				AudioEncoder: ffmpeg.ComponentOptions{Name: "copy"},
				Muxer: ffmpeg.ComponentOptions{
					Name: "mp4",
					Opts: map[string]string{"movflags": "faststart"},
				}}})
		if err != nil {
			return err
		}
	}
	return nil
}
